---
slug: buil-my-blog
category: 前端
categorySlug: frontend
title: 使用Next.js构建我的个人博客
subtitle: ''
author: Tsuizen
description: 身为码农怎么能没有自己的博客，由于博客园的整改风波，出于安全原因决定自己搭建，顺便可以练习技术以及督促自己更新🧐。
tags:
  - Next.js
  - 前端性能优化
featureImage: ''
createdAt: 2023-01-18
updatedAt: 2023-01-18
draft: false
---

## 框架选择

我对博客的需求不需要过于复杂的交互，快速响应，展示内容才是最重要的，因此考虑服务端渲染的方式。

我的技术栈偏向于 React，因此 Nuxt.js，Vuepress 首先被排除在外，React 元框架有 Gatsby，Next.js，Remix
以及同时支持 React，Vue 和 Svelte 的 Astro。其中 Gatsby 的数据来源和 GraphQL 强绑定，虽然它有丰富的博客相关生态，
但我想要一种更通用的开发框架因此被排除在外。Remix 和 Astro 风头正劲，但是我对两者的了解不多，Next.js
似乎就成了目前的不二选择（其实已经在考虑用新技术重构了 🤔

## 关于 MDX

> MDX 是一种书写格式，允许你在 Markdown 文档中无缝地插入 JSX 代码。 你还可以导入（import）组件，例如交互式图表或弹框，并将它们 嵌入到内容当中。 这使得用组件编写较长的内容形成了 一场冲击 🚀。

在 Next.js 中可以通过 `next/mdx` 官方插件或者第三方库来处理 MDX 文件。

- `next/mdx` 其实就是将 MDX 文件交给 Webpack 进行编译处理，并将其视作一个单独的页面。
  但是每次新增插件或者自定义组件都要在 next.config.js 文件中修改，开发体验并不友好。
- 常用的第三方库有 `next-mdx-remote` 和 `mdx-bundler`，其中 `mdx-bundler` 可以导入外部组件，
  因而成了我的首选项。

关于怎么在 Next.js 中使用 MDX 篇幅有限，我会再写一篇文章详细展开。

## 原子化 CSS 框架

前端 JS 框架可谓日新月异，极大地扩展了工程难度。而在 CSS 领域，BEM，CSS Module 等都是顺应这一变化的产物。
近年来，原子化框架的概念在国外受到广泛追捧，[Tailwindcss](https://www.tailwindcss.cn/docs) 就是其中的佼佼者。

一开始我是比较抗拒使用它的，其理念和前端入门时受到的规范教育背道而驰。然而在跟随潮流试用之后我还是加入了真香大军。

关于维护困难我个人并未感受到（或许是因为个人项目的原因），在 class 中直接写语义化类名并配合 vscode
插件反倒是让我摆脱了来回切换文件，以及思考某些冷门 css 属性用法的烦恼。并且框架自带的规范样式以及基于 TailwindCSS
的 [DaisyUI](https://daisyui.com/) 让我这个设计盲也能轻松写出不那么难看的页面来。 同时借助 TailwindCSS 的自定义功能，让我在实现深色模式时免去了不少麻烦。

但是完全脱离手写 CSS 也并不现实，例如在配置 grid-area 以及定义 MDX 组件样式时就显得力不从心。因此我同时使用了
SCSS 进行补充，而且在 css 文件中也可以复用 TailwindCSS 属性。

```css
h1 {
  @apply text-4xl mt-14 mb-10;
}
```

## 或许是 React 最佳的状态管理库

## RSS 订阅支持

> RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，其中包含来自网站的更新摘要，通常采用带有链接的文章列表的形式。

现在使用 RSS 订阅的人越来越少了，但是对我而言，在信息过剩的时代通过 RSS 过滤不相干的推荐信息是保持高效获取信息的必要手段。
本章我会介绍如何在博客中添加 RSS 订阅功能

为个人博客添加 RSS 支持需要用到一个同名包

```shell
pnpm add rss -D
```

接着，创建一个 RSS 对象，里面包含了你博客的标题，描述，url 等信息

```typescript
const feed = new RSS({
  title: "Tsuizen's blog",
  description: '随便写东西的地方，主要以前端内容为主',
  site_url: siteUrl,
  feed_url: `${siteUrl}/feed.xml`,
  language: 'cn',
  pubDate: new Date(),
  copyright: `All rights reserved ${new Date().getFullYear()}, Tsuizen`
});
```

全部属性可参考[RSS channel 属性](https://www.runoob.com/rss/rss-channel.html)

然后遍历所有的文章并添加文章信息

```typescript
allPosts.map((post) => {
  feed.item({
    title: post.title,
    url: `${siteUrl}/posts/${post.title}`,
    date: post.date,
    description: post.description
  });
});
```

可以添加的信息请参考[RSS item 元素](https://www.runoob.com/rss/rss-item.html)

最后将其写入 public 目录即可，完整代码如下

```typescript
import { writeFileSync } from 'fs';
import RSS from 'rss';

import { Post } from '@/types';

import { getRecentPosts } from './posts';

type RSSPost = Pick<Post, 'title' | 'createdAt' | 'description'> & {
  date: Date;
  url: string;
};

const getRSS = async () => {
  const siteUrl = process.env.SITE_URL;
  const allPosts = await getRecentPosts<RSSPost>([
    'title',
    'createdAt',
    'description'
  ]);

  const feed = new RSS({
    title: "Tsuizen's blog",
    description: '随便写东西的地方，主要以前端内容为主',
    site_url: siteUrl,
    feed_url: `${siteUrl}/feed.xml`,
    language: 'cn',
    pubDate: new Date(),
    copyright: `All rights reserved ${new Date().getFullYear()}, Tsuizen`
  });

  allPosts.map((post) => {
    feed.item({
      title: post.title,
      url: `${siteUrl}/posts/${post.title}`,
      date: post.date,
      description: post.description
    });
  });

  writeFileSync('./public/feed.xml', feed.xml({ indent: true }));
};

export default getRSS;
```

要让博客在 build 时更新 xml 文件，还需要在 `page/index.tsx` 中的 `getStaticProps` 添加执行语句，

```typescript
export async function getStaticProps() {
  ...

  await getRSS();

  ...
}
```

现在 build 项目后就可以看见 public 目录中生成了 `feed.xml`，访问`/feed.xml`就可以订阅 RSS 了

## 为博客添加 SEO 和站点地图
